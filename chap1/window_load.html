<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Load</title>
    <!-- defer 옵션을 사용하면 DomcontentLoaded 되기 전에 스크립트를 실행해준다. -->
    <!-- 일반적으로 head에 스크립트를 삽입하면 HTML을 파싱하던 중 js 파일을 받아오고 -->
    <!-- 실행한 뒤 (실행중에는 파싱 멈춤) 다시 페이지를 파싱한다. 따라서 js파일 크기가 매우 크면 -->
    <!-- 랜더링 시간이 너무 오래걸려 좋은 방법이 아니다. -->
    <!-- 따라서 HTML5에서 나온게 head에 script async 속성과 defer 속성이다. -->
    <!-- async는 HTML 파싱과 JS 불러오기(만)!!!를 병렬적으로 동시에 진행한다. -->
    <!-- 하지만 JS를 실행하는 단계에서는 파싱 중지하고  실행 완료 후 다시 파싱 진행하기 때문에-->
    <!-- HTML이 모두 실행되기 전 JS가 실행이 되고 다운로드가 완료된 순서대로 JS파일을 실행하기 때문에 -->
    <!-- 순서에 상관없이 실행되어 순서에 의존적인 페이지라면 문제가 된다. -->
    <!-- defer의 경우 파싱과 js 불러오기(만)!!은 병렬적으로 진행하되 -->
    <!-- js파일은 일단 불러오기만 해놓고 HTML 파싱 끝나면 실행한다. -->
    <!-- 따라서 원하는 순서대로 스크립트 실행가능하다. -->
    <!-- 따라서 외부 스크립트를 불러올 때는 defer 속성이 최선이다. -->
    <!-- 스크립트 순서가 상관없으면 async도 가능하다 -->
    <script src="./test.js" defer></script>
    <style>

    </style>
</head>

<body>

    <!-- 바디끝에 스크립트를 쓰면 HTML을 먼저 파싱 다 하고 JS파일을 받아오고 실행한다. -->
    <!-- 화면 랜더링 속도 측면에서는 효과적이나 HTML파일이 큰경우 JS 가 포함된 의미있는 컨텐츠는 -->
    <!-- 보는데 시간이 너무 오래 걸려 좋은방법이 아니다. -->
    <script>
        // DomContentLoaded은 document(html)만 로드 되어도 호출됨
        // 따라서 페이지 안에 리소스가 많은 경우 리소스를 읽기전
        // DomContentLoaded할때 호출하면 사용자가 더 빨리 볼 수 있다.
        window.addEventListener('DOMContentLoaded', () => {
            console.log('DOMContentLoaded')
        })
        // load는 after resources (css, font, images 등등)이 다 다운로드가 되고 호출 됨
        window.addEventListener('load', () => {
            console.log('load')
        })
        // unload 되기 전에 호출
        window.addEventListener('beforeunload', () => {
            console.log('beforeunload')
        })
        // resource들이 다 unload 되었을 때 호출이 됨
        window.addEventListener('unload', () => {
            console.log('unload')
        })
    </script>
</body>

</html>