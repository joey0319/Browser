/**
 * 자바스크립트 엔진 구조
 * 자바스크립트 코드를 한줄한줄 해석하면서 데이터는 메모리힙에 함수는 콜스택에 저장한다.
 * 메모리 힙 + 콜 스택
 * 메모리 힙 - 변수에 있는 데이터들을 저장
 * 콜 스택 - 함수를 실행하는 순서에 따라 쌓아놓는다.
 */

/** 자바스크립트 런타임 환경
 * 콜 스택에 쌓여져 있는 setTimeOut을 생각해보자
 * 3초후에 콘솔을 찍는 콜백함수를 지정해두었다면
 * setTimeout함수가 실행되자 마자 콜스택에서는 사라진다.
 * 그리고 WebAPI에서 3초를 센다 이러는 동안 동시에 콜스택에서는 남겨져있는 함수들은 계속 실행된다.
 * 3초후에 WebAPIs는 등록한 콜백함수(콘솔찍는)를 Task Queue에 넘긴다.
 * 그러면 이벤트 루프라는 관찰자가 콜스택이 비어있으면 Task Queue에서 콜백을 빼서 콜 스택에 넣는다.
 * 그리고 콜스택에서 콜백함수(콘솔찍는)가 자바스크립트 엔진에 의해 실행된다.
 */

/** Microtask Queue
 * promise에 등록된 콜백 + mutation observer에 등록된 콜백이 마이크로 테스크 큐에 들어온다.
 * 
 */

/** Render
 * Request Animation Frame이라는 Web API가 잇다.
 * 이것은 다음에 렌더링 하기 전에 내가 등록한 콜백을 실행해달라는 명령이다.
 * 그때 이 콜백은 Request Animation Frame이라는 곳에 queue형태로 차곡차곡 쌓인다.
 */

/** 이벤트 루프의 큰그림
 * 콜스택에 함수가 남아있다면 이벤트 루프는 회전하지 않고 그곳에서 대기한다.
 * 콜백이 비게되면 다시 회전한다.
 * 보통 한바퀴 도는데 1ms도 소요되지 않는다.
 * 이러한 상황에서 사람의 눈은 16.7ms에 한번씩 깜빡이면 애니메이션이 자연스럽다고 여긴다.(60fps)
 * 그래서 렌더쪽에는 브라우저 마다 정해진 시간이 다르지만 매번 방문하는 것이 아니고 16ms에 한번씩만 방문한다.
 * 그 후 마이크로 테스크 큐에 방문하여 안에 콜백이 있으면 콜 스택에 넣어준다.(마이크로 테스크 큐가 빌 때까지 마이크로 테스크 큐에서만 콜백을 꺼내 콜스택으로 옮긴다. 테스크 큐에는 가지 않는다.)
 * 그 다음 순회하면서 테스크 큐를 방문한다.
 * 테스크의 경우에는 한번 돌 때 딱 하나만 콜스택으로 옮긴다.(마이크로 테스크 큐와 다르다.)
 * 하나 옮기고 나서 시선을 바로 콜스택으로 옮긴다. 그리고 콜스택이 비게 되면 다시 회전한다.
 * 그렇게 회전하다가 이제는 브라우저 화면을 업데이트 할 시간이 되면 Render로 들어가서
 * request animation frame 안에있는 콜백들을 모조리 다 처리하고 난 뒤
 * Render Tree를 만들고 Layout을 만들고 Paint를 하고 Composite한다.
 */